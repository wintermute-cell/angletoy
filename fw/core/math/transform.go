package math

import (
	"math"

	rl "github.com/gen2brain/raylib-go/raylib"
)

// Transformable is an interface that should be implemented by any object that
// can be transformed.
type Transformable interface {
	GetTransform() *Transform2D
	SetTransform(Transform2D) // This does not take a pointer by design.
}

// Transform2D is a struct that holds the position, rotation, and scale of an entity.
// Do NOT set any of the fields directly. Use the Set* methods instead.
type Transform2D struct {
	position rl.Vector2
	rotation float32
	scale    rl.Vector2

	// matrix is the transformation matrix of the Transform2D struct, representing
	// the Position, Rotation, and Scale fields. It is generated by calling
	// UpdateMatrix(), but uses this cached value until the Position, Rotation,
	// or Scale fields are changed.
	matrix Matrix3
	dirty  bool
}

// ============================================================================
//		CONSTRUCTORS
// ============================================================================

// Transform2DZero returns a "zero value" Transform2D struct.
// Position is (0, 0), Rotation is 0deg, and Scale is (1, 1).
func Transform2DZero() Transform2D {
	return Transform2D{
		position: rl.Vector2{X: 0, Y: 0},
		rotation: 0,
		scale:    rl.Vector2{X: 1, Y: 1},
		matrix:   Matrix3Identity(),
	}
}

// NewTransform2D creates a new Transform2D struct with the given position, rotation, and scale.
func NewTransform2D(position rl.Vector2, rotation float32, scale rl.Vector2) Transform2D {
	nt := Transform2D{
		position: position,
		rotation: rotation,
		scale:    scale,
		dirty:    true,
	}
	return nt
}

// NewTransform2DFromMatrix3 creates a new Transform2D struct from the given matrix.
func NewTransform2DFromMatrix3(matrix Matrix3) Transform2D {

	//
	// the upper left 2x2 of the matrix is the scale and rotation
	//
	// sx*cos(theta)  -sy*sin(theta)
	// sx*sin(theta)   sy*cos(theta)
	//
	// due to the pythagorean identity, we can find the scale by taking the
	// square root of the sum of the squares of the first two elements.
	//
	// sx = sqrt((sx*ct)^2 + (-sy*st)^2)
	//    = sqrt(sx^2 * (ct^2 + st^2))
	//	  = sqrt(sx^2 * 1)
	//
	// same goes for sy. the negative sign on sx is irrelevant due to the
	// squaring.
	//
	scaleX := math.Sqrt(float64(matrix.m0*matrix.m0 + matrix.m1*matrix.m1))
	scaleY := math.Sqrt(float64(matrix.m3*matrix.m3 + matrix.m4*matrix.m4))

	// rotation is the atan2 of st and ct. we use atan2 because it can handle
	// the full range of angles and not just -pi/2 to pi/2 rad.
	rotRad := math.Atan2(
		float64(matrix.m3)/scaleY, // m3 = sin(theta) * sy
		float64(matrix.m4)/scaleY, // m4 = cos(theta) * sy
	)
	rotDeg := float32(rotRad * (180 / math.Pi))

	nt := Transform2D{
		position: rl.NewVector2(matrix.m2, matrix.m5), // m2 = tx, m5 = ty, these are trivial
		rotation: rotDeg,
		scale:    rl.NewVector2(float32(scaleX), float32(scaleY)),
		matrix:   matrix,
		dirty:    false,
	}
	return nt
}

// ============================================================================
//		METHODS
// ============================================================================

// GenerateMatrix creates a new Matrix of the Transform2D struct, based on
// the Position, Rotation, and Scale fields.
func (t *Transform2D) GenerateMatrix() Matrix3 {
	// if the transform was changed, generate a new matrix to update the cached
	// value.
	if t.dirty {
		t.matrix = Matrix3Identity()
		t.matrix = t.matrix.Multiply(Matrix3Translation(t.position))
		t.matrix = t.matrix.Multiply(Matrix3Rotation(t.rotation))
		t.matrix = t.matrix.Multiply(Matrix3Scale(t.scale))
		t.dirty = false
	}
	return t.matrix
}

// SetPosition sets the Position field of the Transform2D struct.
func (t *Transform2D) SetPosition(new_position rl.Vector2) {
	t.position = new_position
	t.dirty = true
}

// SetScale sets the Scale field of the Transform2D struct.
func (t *Transform2D) SetScale(new_scale rl.Vector2) {
	t.scale = new_scale
	t.dirty = true
}

// SetRotation sets the Rotation field of the Transform2D struct.
func (t *Transform2D) SetRotation(new_rotation float32) {
	t.rotation = new_rotation
	t.dirty = true
}

// GetPosition returns the Position field of the Transform2D struct.
func (t *Transform2D) GetPosition() rl.Vector2 {
	return t.position
}

// GetScale returns the Scale field of the Transform2D struct.
func (t *Transform2D) GetScale() rl.Vector2 {
	return t.scale
}

// GetRotation returns the Rotation field of the Transform2D struct.
func (t *Transform2D) GetRotation() float32 {
	return t.rotation
}

// AddPosition adds a vector to the Position field of the Transform2D struct.
func (t *Transform2D) AddPosition(offset rl.Vector2) {
	t.position = rl.Vector2Add(t.position, offset)
	t.dirty = true
}

// AddScale adds a vector to the Scale field of the Transform2D struct.
func (t *Transform2D) AddScale(offset rl.Vector2) {
	t.scale = rl.Vector2Add(t.scale, offset)
	t.dirty = true
}

// AddRotation adds a value to the Rotation field of the Transform2D struct.
func (t *Transform2D) AddRotation(offset float32) {
	t.rotation += offset
	t.dirty = true
}
